/* This file is generated by `npm run es5`, do not modify */
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

module.exports = (function () {
  // Instantiate a new Zorkbot
  //
  // Required arguments:
  //   `places` - An object describing a set of places. See README.md.
  //   `startingPlace` - The name of the starting point. Must correspond to a
  //     key in the `places` object.
  //
  // Optional arguments:
  //   `initialState` - An object containing the starting state information.

  function Zorkbot(places, startingPlace, initialState) {
    _classCallCheck(this, Zorkbot);

    if (!places || !startingPlace) {
      throw new Error('Missing required arguments');
    }

    this.places = places;
    this.position = places[startingPlace];

    if (!this.position) {
      throw new Error('Invalid starting place: ' + startingPlace);
    }

    this.state = initialState || {};
  }

  // Returns a Promise, which will resolve with a String prompt.

  _createClass(Zorkbot, [{
    key: 'getPrompt',
    value: function getPrompt() {
      if (this.position === false) {
        return Promise.reject(new Error("Can't continue past the end"));
      }

      return Promise.resolve(this.position.getPrompt(this.state));
    }

    // Returns a Promise, which will resolve with a Boolean.
    // `true` indicates that the story is still in progress (i.e. there's another
    // prompt available), `false` indicates we've come to the end.
  }, {
    key: 'handleResponse',
    value: function handleResponse(response) {
      var _this = this;

      if (this.position === false) {
        return Promise.reject(new Error("Can't continue past the end"));
      }

      return Promise.resolve(this.position.handleResponse(response, this.state)).then(function (destinationName) {
        if (destinationName === false) {
          // The story is over.
          _this.position = false;
          return false;
        }

        _this.position = _this.places[destinationName];

        if (_this.position === undefined) {
          throw new Error('Invalid destination: ' + destinationName);
        }

        return true;
      });
    }
  }]);

  return Zorkbot;
})();

